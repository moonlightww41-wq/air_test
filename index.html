<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>運賃検索（複数旅程対応）</title>
  <style>
:root{
  --bg:#0b1020;
  --card:#121a33;
  --card2:#0f1730;
  --text:#e9ecf5;
  --muted:#9aa4c7;
  --line:rgba(255,255,255,.08);
  --shadow: 0 10px 30px rgba(0,0,0,.35);
  --radius:18px;
  --blue:#5aa7ff;
  --purple:#a78bfa;
  --green:#34d399;
  --red:#fb7185;
  --amber:#fbbf24;
}
*{box-sizing:border-box}
html,body{height:100%}
body{
  margin:0;
  font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Hiragino Kaku Gothic ProN","Meiryo", "Noto Sans JP", sans-serif;
  background: radial-gradient(900px 700px at 20% 0%, rgba(90,167,255,.18), transparent 55%),
              radial-gradient(900px 700px at 90% 10%, rgba(167,139,250,.18), transparent 55%),
              radial-gradient(900px 700px at 30% 100%, rgba(52,211,153,.12), transparent 55%),
              var(--bg);
  color:var(--text);
}
a{color:inherit}
code{background:rgba(255,255,255,.08); padding:.12rem .35rem; border-radius:.45rem}
.topbar{
  position:sticky; top:0;
  display:flex; justify-content:space-between; align-items:center;
  padding:14px 18px;
  backdrop-filter: blur(12px);
  background: rgba(10,14,30,.75);
  border-bottom: 1px solid var(--line);
  z-index:10;
}
.brand{display:flex; gap:12px; align-items:center}
.logo{font-size:22px}
.titles .title{font-weight:800; letter-spacing:.02em; font-size:16px}
.titles .subtitle{font-size:12px; color:var(--muted); margin-top:2px}
.badges{display:flex; gap:8px; flex-wrap:wrap; justify-content:flex-end}
.badge{
  font-size:12px;
  padding:6px 10px;
  border-radius:999px;
  border:1px solid var(--line);
  background:rgba(255,255,255,.06);
}
.badge-blue{border-color: rgba(90,167,255,.35); color:#cfe6ff}
.badge-purple{border-color: rgba(167,139,250,.35); color:#e6dcff}
.badge-green{border-color: rgba(52,211,153,.35); color:#d6fff0}

.wrap{max-width:1180px; margin:18px auto 36px; padding:0 16px}
.card{
  background: linear-gradient(180deg, rgba(255,255,255,.05), rgba(255,255,255,.03));
  border: 1px solid var(--line);
  border-radius: var(--radius);
  box-shadow: var(--shadow);
  padding:16px;
  margin:14px 0;
}
.card-h{display:flex; align-items:flex-end; justify-content:space-between; gap:14px; flex-wrap:wrap}
.card h2{margin:0; font-size:16px}
.hint{color:var(--muted); font-size:12px; line-height:1.3}
.grid2{display:grid; grid-template-columns: 1.15fr .85fr; gap:14px; margin-top:14px}
@media (max-width: 980px){ .grid2{grid-template-columns:1fr} }

textarea, input, select{
  width:100%;
  border-radius: 14px;
  border: 1px solid var(--line);
  background: rgba(10,14,30,.55);
  color: var(--text);
  padding:12px 12px;
  outline:none;
}
textarea:focus, input:focus, select:focus{border-color: rgba(90,167,255,.55)}
.mono{font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace}
.row{display:flex; gap:10px; align-items:center; margin-top:10px; flex-wrap:wrap}
.btn{
  border:1px solid var(--line);
  background: rgba(255,255,255,.06);
  color: var(--text);
  padding:10px 14px;
  border-radius: 14px;
  cursor:pointer;
  font-weight:650;
}
.btn:hover{background: rgba(255,255,255,.09)}
.btn.primary{
  background: linear-gradient(180deg, rgba(90,167,255,.28), rgba(90,167,255,.12));
  border-color: rgba(90,167,255,.45);
}
.btn.ghost{background: transparent}
.msg{margin-top:10px; font-size:12px; color:var(--muted)}
.panel{
  border-radius: var(--radius);
  border: 1px solid var(--line);
  background: rgba(0,0,0,.18);
  padding:12px;
}
.panel h3{margin:0 0 10px; font-size:14px}
.formRow{display:grid; grid-template-columns: 90px 1fr; gap:10px; align-items:center; margin:8px 0}
.formRow label{color:var(--muted); font-size:12px}
.divider{height:1px; background:var(--line); margin:12px 0}
.legs{display:flex; flex-direction:column; gap:8px}
.legItem{
  display:flex; justify-content:space-between; align-items:center; gap:10px;
  padding:10px 10px;
  border-radius: 14px;
  border:1px solid var(--line);
  background: rgba(255,255,255,.05);
}
.legItem .meta{display:flex; flex-direction:column; gap:3px}
.legItem .meta .m1{font-weight:700}
.legItem .meta .m2{color:var(--muted); font-size:12px}
.legItem .actions{display:flex; gap:8px}
.pill{
  padding:6px 10px;
  border-radius: 999px;
  font-size:12px;
  border:1px solid var(--line);
  background: rgba(255,255,255,.05);
  white-space:nowrap;
}
.pill.red{border-color: rgba(251,113,133,.45); color:#ffd0d9}
.pill.green{border-color: rgba(52,211,153,.45); color:#c8ffeb}

.totals{justify-content:space-between}
.kpi{
  flex:1;
  min-width:160px;
  padding:10px 12px;
  border-radius: 16px;
  border:1px solid var(--line);
  background: rgba(255,255,255,.04);
}
.kpi-label{font-size:12px; color:var(--muted)}
.kpi-value{margin-top:6px; font-size:20px; font-weight:850}
.kpi-value.small{font-size:12px; font-weight:650; color:var(--muted)}

.tableWrap{overflow:auto; margin-top:12px; border-radius: 16px; border:1px solid var(--line)}
.tbl{width:100%; border-collapse:separate; border-spacing:0; min-width:860px}
.tbl thead th{
  position:sticky; top:0;
  background: rgba(15,23,48,.96);
  border-bottom: 1px solid var(--line);
  padding:10px 10px;
  font-size:12px;
  color: #cfd6f0;
  text-align:left;
}
.tbl tbody td{
  border-bottom: 1px solid var(--line);
  padding:10px 10px;
  font-size:13px;
}
.tbl tbody tr:nth-child(2n) td{background: rgba(255,255,255,.03)}
.tbl tbody tr:hover td{background: rgba(90,167,255,.08)}
.tbl .num{text-align:right; font-variant-numeric: tabular-nums}
.details{margin-top:12px}
.details summary{cursor:pointer; color:#d6ddff}
.diag{display:grid; grid-template-columns: 1fr 1fr; gap:10px; margin-top:10px}
@media (max-width: 980px){ .diag{grid-template-columns:1fr} }
.diag-col{border:1px solid var(--line); border-radius:16px; background:rgba(0,0,0,.18); padding:10px}
.diag-col h4{margin:0 0 8px; font-size:13px}
.footer{padding:18px; text-align:center; color:var(--muted); font-size:12px}
.bullets{margin:8px 0 0 20px; color:var(--muted); font-size:13px; line-height:1.6}

</style>
</head>
<body>
  <header class="topbar">
    <div class="brand">
      <div class="logo">✈️</div>
      <div class="titles">
        <div class="title">運賃検索</div>
        <div class="subtitle">複数旅程をまとめて計算（テキスト貼り付け or 追加フォーム）</div>
      </div>
    </div>
    <div class="badges">
      <span class="badge badge-blue">CSV自動読込</span>
      <span class="badge badge-purple">同義語吸収</span>
      <span class="badge badge-green">期間判定</span>
    </div>
  </header>

  <main class="wrap">
    <section class="card">
      <div class="card-h">
        <h2>① 旅程入力（テキスト貼り付け）</h2>
        <div class="hint">例：<code>2025-08-21 東京→沖縄</code> / <code>8/22 沖縄→宮古</code>（矢印は → / -> / 〜 などOK）</div>
      </div>
      <div class="grid2">
        <div>
          <textarea id="itineraryText" class="mono" rows="8" placeholder="例）
2025-08-21 東京→沖縄
2025-08-22 沖縄→宮古
2025-08-24 宮古→東京"></textarea>
          <div class="row">
            <button id="btnParse" class="btn primary">解析して検索</button>
            <button id="btnClear" class="btn ghost">クリア</button>
          </div>
          <div id="parseMsg" class="msg"></div>
        </div>

        <div class="panel">
          <h3>② 旅程入力（フォームで追加）</h3>
          <div class="formRow">
            <label>日付</label>
            <input id="legDate" type="date" />
          </div>
          <div class="formRow">
            <label>出発地</label>
            <select id="fromSelect"></select>
          </div>

          <div class="formRow">
            <label>経由地①</label>
            <select id="via1Select"></select>
          </div>
          <div class="formRow">
            <label>経由地②</label>
            <select id="via2Select"></select>
          </div>

          <div class="formRow">
            <label>到着地</label>
            <select id="toSelect"></select>
          </div>
          <div class="row">
            <button id="btnAddLeg" class="btn">旅程を追加</button>
            <button id="btnResetLegs" class="btn ghost">旅程を全削除</button>
          </div>

          <div class="divider"></div>
          <h3>現在の旅程</h3>
          <div id="legsList" class="legs"></div>
        </div>
      </div>
    </section>

    <section class="card">
      <div class="card-h">
        <h2>検索結果</h2>
        <div class="hint">価格タイプ（ピーク/通常）両方ある場合は、該当期間に合致するものを優先。見つからない場合は候補（方向違い・空港別名）も提示。</div>
      </div>

      <div class="row totals">
        <div class="kpi">
          <div class="kpi-label">合計運賃</div>
          <div class="kpi-value" id="sumFare">-</div>
        </div>
        <div class="kpi">
          <div class="kpi-label">ヒット</div>
          <div class="kpi-value" id="hitCount">-</div>
        </div>
        <div class="kpi">
          <div class="kpi-label">未ヒット</div>
          <div class="kpi-value" id="missCount">-</div>
        </div>
        <div class="kpi">
          <div class="kpi-label">データ更新日時</div>
          <div class="kpi-value small" id="dbMeta">-</div>
        </div>
      </div>

      <div class="tableWrap">
        <table class="tbl" id="resultTable">
          <thead>
            <tr>
              <th style="width:120px">日付</th>
              <th style="width:160px">出発地</th>
              <th style="width:160px">到着地</th>
              <th style="width:100px">価格タイプ</th>
              <th style="width:120px" class="num">運賃</th>
              <th>根拠（適用期間）</th>
            </tr>
          </thead>
          <tbody></tbody>
        </table>
      </div>

      <details class="details">
        <summary>データベース診断（未ヒット原因の特定）</summary>
        <div class="diag">
          <div class="diag-col">
            <h4>正規化マップ（place_aliases.csv）</h4>
            <pre id="diagAliases" class="mono"></pre>
          </div>
          <div class="diag-col">
            <h4>未ヒット一覧</h4>
            <pre id="diagMisses" class="mono"></pre>
          </div>
        </div>
      </details>
    </section>

    <section class="card">
      <div class="card-h">
        <h2>データ更新について</h2>
      </div>
      <ul class="bullets">
        <li>このサイトは <code>data/fare_source.tsv</code>（あなたの貼り付けデータ）を読み込み、ブラウザ内で自動的に正規化して検索します。サーバー側の変換作業は不要です。</li>
        <li>CSV/TSVは「UTF-8（BOMあり）」を推奨（文字化け対策）。</li>
        <li>列名は以下が必須です：<code>搭乗期間開始</code> <code>搭乗期間終了</code> <code>出発地</code> <code>到着地</code> <code>価格タイプ</code> <code>運賃</code> <code>価格適用期間</code></li>
      </ul>
    </section>
  </main>

  <footer class="footer">
    <div>© Internal Tool • Transport Fare Calculator</div>
  </footer>

  <script>
/* Transport Fare Calculator (single-file, static)
 * - Reads data/fare_source.tsv (TSV) and optional data/place_aliases.csv
 * - Normalizes and searches fares for multiple itinerary legs
 * - Keeps both text input and dropdown add
 */
const DB = {
  meta: { loadedAt: null, rowCount: 0 },
  faresRows: [],      // array of normalized fare rows
  routeMap: new Map(), // key=from||to -> array of rows
  places: [],
  aliasToCanon: new Map(),
};

const $ = (sel) => document.querySelector(sel);
const $$ = (sel) => Array.from(document.querySelectorAll(sel));



// ---- key normalization & flexible column mapping ----
function stripBOM(s){ return (s || '').toString().replace(/^\uFEFF/, ''); }
function normHeaderKey(k){
  return stripBOM(k)
    .replace(/[\u3000\s]+/g,'')   // remove spaces (incl full-width)
    .replace(/[()（）\[\]【】]/g,'')
    .replace(/[‐‑–—―ー]/g,'-')
    .toLowerCase();
}
function canonicalKey(k){
  const nk = normHeaderKey(k);
  // JP / EN variants -> canonical tokens
  if (['出発地','発地','出発','from','origin','出発場所','発駅','乗車地'].some(x=>nk.includes(normHeaderKey(x)))) return 'from';
  if (['到着地','着地','到着','to','destination','到着場所','着駅','降車地'].some(x=>nk.includes(normHeaderKey(x)))) return 'to';
  if (['運賃','金額','料金','fare','price','運賃額'].some(x=>nk.includes(normHeaderKey(x)))) return 'fare';
  if (['価格タイプ','価格ﾀｲﾌﾟ','シーズン','season','type','区分'].some(x=>nk.includes(normHeaderKey(x)))) return 'priceType';
  if (['搭乗期間開始','搭乗開始','boardfrom','validfrom','搭乗期間from'].some(x=>nk.includes(normHeaderKey(x)))) return 'wholeFrom';
  if (['搭乗期間終了','搭乗終了','boardto','validto','搭乗期間to'].some(x=>nk.includes(normHeaderKey(x)))) return 'wholeTo';
  if (['価格適用期間開始','適用開始','periodfrom','farefrom','価格適用開始'].some(x=>nk.includes(normHeaderKey(x)))) return 'validFrom';
  if (['価格適用期間終了','適用終了','periodto','fareto','価格適用終了'].some(x=>nk.includes(normHeaderKey(x)))) return 'validTo';
  if (['根拠','備考','rule','注記','参照'].some(x=>nk.includes(normHeaderKey(x)))) return 'rule';
  if (['価格適用期間','適用期間'].some(x=>nk.includes(normHeaderKey(x)))) return 'validRange';
  if (['alias','別名','入力','候補','表記ゆれ','表記揺れ','synonym'].some(x=>nk.includes(normHeaderKey(x)))) return 'alias';
  if (['canonical','正規','正規名','統一名','正式名称'].some(x=>nk.includes(normHeaderKey(x)))) return 'canonical';
  return nk; // fallback
}
function normalizeRowKeys(row){
  const out = {};
  for (const [k,v] of Object.entries(row||{})){
    const ck = canonicalKey(k);
    // keep first non-empty value if duplicates appear
    const val = (v ?? '').toString().trim();
    if (!(ck in out) || (out[ck] === '' && val !== '')) out[ck] = val;
  }
  return out;
}
// ---- robust fetch helpers (avoid SPA fallback returning index.html) ----
async function fetchTextFirstOk(urls){
  let lastErr = null;
  for (const u of urls){
    try{
      const res = await fetch(u, { cache: "no-cache" });
      if (!res.ok) { lastErr = new Error(`${u} => ${res.status}`); continue; }
      const txt = await res.text();
      return { url: u, text: txt, status: res.status };
    } catch (e){
      lastErr = e;
    }
  }
  if (lastErr) throw lastErr;
  throw new Error("fetch failed");
}

function looksLikeHTML(text){
  const t = (text ?? "").toString().trim().slice(0,200).toLowerCase();
  return t.startsWith("<!doctype") || t.startsWith("<html") || t.includes("<head") || t.includes("<body");
}

function hasAnyKey(obj, keys){
  return keys.some(k => Object.prototype.hasOwnProperty.call(obj, k));
}

function validateFareRows(rows){
  // Accept either JP headers or EN headers (TSV sample)
  if (!Array.isArray(rows) || !rows.length) return false;
  const first = rows[0] || {};
  const jpOk = hasAnyKey(first, ["出発地"]) && hasAnyKey(first, ["到着地"]) && hasAnyKey(first, ["運賃"]);
  const enOk = hasAnyKey(first, ["origin"]) && hasAnyKey(first, ["destination"]) && hasAnyKey(first, ["fare"]);
  return jpOk || enOk;
}

function norm(s){
  return (s ?? "").toString().trim()
    .replace(/[\s\u3000]+/g,"")
    .replace(/[‐‑–—−]/g,"-")
    .toLowerCase();
}

// Normalize key for matching (places / aliases)
function normKey(s) {
  // Based on norm(), plus remove Japanese middle dots etc.
  return norm(s).replace(/[・･]/g, '').replace(/[()（）\[\]【】]/g, '');
}


function parseDateLoose(s){
  const t = (s ?? "").toString().trim();
  if (!t) return null;

  // YYYY-MM-DD
  let m = t.match(/^(\d{4})-(\d{1,2})-(\d{1,2})$/);
  if (m) return new Date(Number(m[1]), Number(m[2])-1, Number(m[3]));

  // YYYY/MM/DD
  m = t.match(/^(\d{4})\/(\d{1,2})\/(\d{1,2})$/);
  if (m) return new Date(Number(m[1]), Number(m[2])-1, Number(m[3]));

  // YYYY/MM
  m = t.match(/^(\d{4})\/(\d{1,2})$/);
  if (m) return new Date(Number(m[1]), Number(m[2])-1, 1);

  // M/D or M-D (assume current year)
  m = t.match(/^(\d{1,2})[\/\-](\d{1,2})$/);
  if (m) {
    const y = new Date().getFullYear();
    return new Date(y, Number(m[1])-1, Number(m[2]));
  }

  return null;
}

function ymd(d){
  if (!d) return "";
  const y = d.getFullYear();
  const m = String(d.getMonth()+1).padStart(2,"0");
  const day = String(d.getDate()).padStart(2,"0");
  return `${y}-${m}-${day}`;
}

function money(n){
  if (n == null || !Number.isFinite(n)) return "-";
  return Math.trunc(n).toLocaleString("ja-JP");
}

function parseTSV(text){
  const lines = text.replace(/\r/g,"").split("\n").filter(l => l.trim() !== "");
  if (!lines.length) return [];
  const header = lines[0].split("\t").map(h=>h.trim());
  const rows = [];
  for (let i=1;i<lines.length;i++){
    const cols = lines[i].split("\t");
    const r = {};
    for (let j=0;j<header.length;j++){
      r[header[j]] = (cols[j] ?? "").trim();
    }
    rows.push(r);
  }
  return rows;
}

function parseCSV(text){
  // minimal CSV parser (handles quoted commas)
  const rows = [];
  let cur = [];
  let cell = "";
  let inQ = false;
  for (let i=0;i<text.length;i++){
    const ch = text[i];
    const next = text[i+1];
    if (inQ){
      if (ch === '"' && next === '"'){ cell += '"'; i++; }
      else if (ch === '"'){ inQ = false; }
      else cell += ch;
    } else {
      if (ch === '"'){ inQ = true; }
      else if (ch === ','){ cur.push(cell); cell = ""; }
      else if (ch === '\n'){ cur.push(cell); rows.push(cur); cur = []; cell = ""; }
      else if (ch === '\r'){ /* skip */ }
      else cell += ch;
    }
  }
  if (cell.length || cur.length) { cur.push(cell); rows.push(cur); }
  if (!rows.length) return [];
  const header = rows[0].map(h=> (h ?? "").toString().replace(/^\ufeff/, "").trim());
  const out = [];
  for (let i=1;i<rows.length;i++){
    if (rows[i].every(x => (x ?? "").trim() === "")) continue;
    const obj = {};
    for (let j=0;j<header.length;j++){
      obj[header[j]] = (rows[i][j] ?? "").trim();
    }
    out.push(obj);
  }
  return out;
}

function splitPeriods(periodStr){
  // "2025-06-01〜2025-06-30 / 2025-09-01〜2025-10-25"
  const t = (periodStr ?? "").toString().trim();
  if (!t) return [];
  const parts = t.split("/").map(p=>p.trim()).filter(Boolean);
  const ranges = [];
  for (const p of parts){
    const m = p.match(/(\d{4}-\d{2}-\d{2})\s*[〜~\-]\s*(\d{4}-\d{2}-\d{2})/);
    if (!m) continue;
    const a = parseDateLoose(m[1]);
    const b = parseDateLoose(m[2]);
    if (a && b) ranges.push([a,b]);
  }
  return ranges;
}

function buildAliasDefaultsFromPlaces(places){
  // also accept "東京都" -> "東京" style: strip 都道府県 suffix if exact match
  const m = new Map();
  for (const p of places){
    m.set(norm(p), p);
  }
  // common suffix variants
  for (const p of places){
    const np = norm(p);
    // if place ends with 空港 etc keep itself as canonical
    // create variants with 都/道/府/県 removed
    const variants = [
      p.replace(/(都|道|府|県)$/,""),
      p.replace(/空港$/,""),
    ].filter(v=>v && v !== p);
    for (const v of variants){
      if (!m.has(norm(v))) m.set(norm(v), p);
    }
  }
  // hard common arrows / city tokens:
  const common = [
    ["東京","東京"],["羽田","東京"],["成田","東京"],
    ["沖縄","沖縄"],["那覇","沖縄"],
  ];
  for (const [a,c] of common){
    if (places.includes(c) && !m.has(norm(a))) m.set(norm(a), c);
  }
  return m;
}

function resolvePlace(name){
  const k = norm(name);
  if (!k) return "";
  return DB.aliasToCanon.get(k) || name.trim();
}

function inRange(d, a, b){
  // inclusive
  const x = d.getTime();
  return x >= a.getTime() && x <= b.getTime();
}

function findFare(date, from, to){
  const d = date;
  const f = resolvePlace(from);
  const t = resolvePlace(to);

  // Use routeMap when available (faster and avoids full-scan)
  const keyFT = normKey(f) + '||' + normKey(t);
  const keyTF = normKey(t) + '||' + normKey(f);
  const listFT = DB.routeMap?.get(keyFT) || null;
  const listTF = DB.routeMap?.get(keyTF) || null;

  const pick = (arr) => {
    const cands = (arr || []).filter(r => inRange(d, r.validFrom, r.validTo));
    if (!cands.length) return null;
    cands.sort((a,b)=> (a.validTo-a.validFrom) - (b.validTo-b.validFrom) || (a.priceType === "ピーク" ? -1 : 1));
    return cands[0];
  };

  // exact direction first
  let best = pick(listFT || DB.routeMap.filter(r => r.from === f && r.to === t));
  if (best){
    return { hit:true, row:best, from:f, to:t, tried:[`${f}→${t}`] };
  }

  // try reverse direction (some data may be one-way)
  best = pick(listTF || DB.routeMap.filter(r => r.from === t && r.to === f));
  if (best){
    return { hit:true, row:{...best, note:"※逆方向データを使用"}, from:f, to:t, tried:[`${f}→${t}`, `${t}→${f}`] };
  }

  // no hit
  // show top 5 near matches by from/to only
  const near = DB.routeMap.filter(r => (r.from===f && r.to===t) || (r.from===t && r.to===f));
  near.sort((a,b)=> a.validFrom - b.validFrom);
  return { hit:false, row:null, from:f, to:t, tried:[`${f}→${t}`, `${t}→${f}`], near: near.slice(0,5) };
}

function parseItineraryLines(text){
  const lines = (text ?? "").split(/\r?\n/).map(l=>l.trim()).filter(Boolean);
  const legs = [];
  const errors = [];
  for (const line of lines){
    // date token at start
    const m = line.match(/^([0-9]{4}[\/-][0-9]{1,2}[\/-][0-9]{1,2}|[0-9]{1,2}[\/-][0-9]{1,2})\s*(.+)$/);
    if (!m){ errors.push(`日付が読み取れません: ${line}`); continue; }
    const d = parseDateLoose(m[1]);
    if (!d){ errors.push(`日付形式が不正: ${line}`); continue; }
    const rest = m[2].trim();

    // split by arrow or hyphen
    const arrow = rest.replace(/→/g,"->").replace(/⇒/g,"->").replace(/ー/g,"-");
    const m2 = arrow.match(/^(.+?)\s*(?:->|〜|~|-)\s*(.+)$/);
    if (!m2){ errors.push(`出発地/到着地が読み取れません: ${line}`); continue; }
    const from = m2[1].trim();
    const to = m2[2].trim();
    if (!from || !to){ errors.push(`出発地/到着地が空です: ${line}`); continue; }
    legs.push({ date: d, from, to, raw: line });
  }
  return { legs, errors };
}

function renderLegs(){
  const wrap = $("#legsList");
  wrap.innerHTML = "";
  if (!window.__legs || !window.__legs.length){
    wrap.innerHTML = `<div class="msg">まだ旅程がありません。</div>`;
    return;
  }
  window.__legs.forEach((leg, idx)=>{
    const el = document.createElement("div");
    el.className = "legItem";
    el.innerHTML = `
      <div class="meta">
        <div class="m1">${ymd(leg.date)}　${leg.from} → ${leg.to}</div>
        <div class="m2">${leg.raw || ""}</div>
      </div>
      <div class="actions">
        <button class="btn ghost" data-act="up" data-idx="${idx}">↑</button>
        <button class="btn ghost" data-act="down" data-idx="${idx}">↓</button>
        <button class="btn" data-act="del" data-idx="${idx}">削除</button>
      </div>
    `;
    wrap.appendChild(el);
  });

  wrap.querySelectorAll("button").forEach(btn=>{
    btn.addEventListener("click", ()=>{
      const act = btn.getAttribute("data-act");
      const idx = Number(btn.getAttribute("data-idx"));
      if (act === "del"){ window.__legs.splice(idx,1); }
      if (act === "up" && idx>0){
        const t = window.__legs[idx-1]; window.__legs[idx-1]=window.__legs[idx]; window.__legs[idx]=t;
      }
      if (act === "down" && idx<window.__legs.length-1){
        const t = window.__legs[idx+1]; window.__legs[idx+1]=window.__legs[idx]; window.__legs[idx]=t;
      }
      renderLegs();
      runSearch();
    });
  });
}

function renderSelectOptions(){
  const fromSel = $("#fromSelect");
  const toSel = $("#toSelect");
  const via1Sel = $("#via1Select");
  const via2Sel = $("#via2Select");

  const prev = {
    from: fromSel?.value || "",
    to: toSel?.value || "",
    via1: via1Sel?.value || "",
    via2: via2Sel?.value || ""
  };

  const opts = DB.places.slice().sort((a,b)=>a.localeCompare(b,"ja"));

  function fill(sel, includeBlank){
    if (!sel) return;
    sel.innerHTML = "";
    if (includeBlank){
      const ob = document.createElement("option");
      ob.value = ""; ob.textContent = "（未指定）";
      sel.appendChild(ob);
    }
    for (const p of opts){
      const o = document.createElement("option");
      o.value = p; o.textContent = p;
      sel.appendChild(o);
    }
  }

  fill(fromSel, false);
  fill(toSel, false);
  fill(via1Sel, true);
  fill(via2Sel, true);

  if (prev.from && opts.includes(prev.from)) fromSel.value = prev.from;
  if (prev.to && opts.includes(prev.to)) toSel.value = prev.to;
  if (prev.via1 && opts.includes(prev.via1)) via1Sel.value = prev.via1;
  if (prev.via2 && opts.includes(prev.via2)) via2Sel.value = prev.via2;

  if (!fromSel.value && opts.includes("東京")) fromSel.value = "東京";
  if (!toSel.value && opts.includes("沖縄")) toSel.value = "沖縄";
}


function renderResults(rows, misses){
  const tbody = $("#resultTable tbody");
  tbody.innerHTML = "";
  let sum = 0;
  let hit = 0;
  for (const r of rows){
    const tr = document.createElement("tr");
    const fare = r.hit ? r.row.fare : null;
    if (Number.isFinite(fare)) sum += Math.trunc(fare);
    if (r.hit) hit++;
    tr.innerHTML = `
      <td>${ymd(r.leg.date)}</td>
      <td>${r.from}</td>
      <td>${r.to}</td>
      <td>${r.hit ? (r.row.priceType || "-") : `<span class="pill red">未ヒット</span>`}</td>
      <td class="num">${r.hit ? money(r.row.fare) : "-"}</td>
      <td>${r.hit ? (r.row.seasonLabel ? `${r.row.seasonLabel}${r.row.note?` ${r.row.note}`:""}` : (r.row.note||"")) : (r.near && r.near.length ? `候補あり（期間外/逆方向）` : "データなし")}</td>
    `;
    tbody.appendChild(tr);
  }

  $("#sumFare").textContent = hit ? money(sum) : "-";
  $("#hitCount").textContent = String(hit);
  $("#missCount").textContent = String(rows.length - hit);
  // keep DB status visible even after search rerenders
  if (DB.meta?.source){
    $("#dbMeta").textContent = `DB: ${DB.meta.source} / routes=${DB.meta.routes} / fares=${DB.meta.fares} / places=${DB.meta.places} / updated=${DB.meta.updatedAt}`;
  }

  // diagnostics
  const missLines = misses.map(m => `- ${ymd(m.leg.date)} ${m.from}→${m.to} | tried: ${m.tried.join(" / ")}\n  candidates: ${m.near?.map(n=>`${n.from}→${n.to} ${ymd(n.validFrom)}〜${ymd(n.validTo)} ${n.priceType} ${money(n.fare)}`).join(" | ") || "-"}`).join("\n");
  $("#diagMisses").textContent = missLines || "（未ヒットなし）";

  // show a small alias map sample
  const aliasSample = Array.from(DB.aliasToCanon.entries()).slice(0, 200).map(([k,v])=>`${k} => ${v}`).join("\n");
  $("#diagAliases").textContent = aliasSample || "（aliasなし）";
}

function runSearch(){
  if (!DB.faresRows || DB.faresRows.length === 0) {
    renderResults([], []);
    $("#parseMsg").textContent = "DB未読み込み（運賃データ0件）です。data/transport.csv を確認してください。";
    return;
  }

  const legs = window.__legs || [];
  if (!legs.length){
    renderResults([], []);
    $("#parseMsg").textContent = "旅程がありません。テキスト貼り付けかフォームで追加してください。";
    return;
  }
  $("#parseMsg").textContent = "";

  const results = [];
  const misses = [];
  for (const leg of legs){
    const res = findFare(leg.date, leg.from, leg.to);
    results.push({ ...res, leg });
    if (!res.hit) misses.push({ ...res, leg });
  }
  renderResults(results, misses);
}

async function loadDB(){
  // 1) fares: prefer CSV master (data/transport.csv). fallback to TSV sample.
  let fareRows = null;
  let sourceName = '';

  // Candidate URLs (covers: file root, subdir, Netlify/GitHub Pages base URL)
  const csvUrls = [
    new URL('./data/transport.csv', location.href).toString(),
    new URL('data/transport.csv', location.href).toString(),
    './data/transport.csv',
    'data/transport.csv',
  ];
  const tsvUrls = [
    new URL('./data/fare_source.tsv', location.href).toString(),
    new URL('data/fare_source.tsv', location.href).toString(),
    './data/fare_source.tsv',
    'data/fare_source.tsv',
  ];

  // Try CSV first
  try {
    const got = await fetchTextFirstOk(csvUrls);
    if (looksLikeHTML(got.text)) throw new Error(`transport.csv resolved to HTML (SPA fallback). url=${got.url}`);
    const rows = parseCSV(got.text);
    if (!validateFareRows(rows)) throw new Error(`transport.csv parsed but missing expected headers. url=${got.url}`);
    fareRows = rows;
    sourceName = 'transport.csv';
  } catch (e){
    // fallback TSV
    const got = await fetchTextFirstOk(tsvUrls);
    if (looksLikeHTML(got.text)) throw new Error(`fare_source.tsv resolved to HTML (SPA fallback). url=${got.url}`);
    const rows = parseTSV(got.text);
    if (!validateFareRows(rows)) throw new Error(`fare_source.tsv parsed but missing expected headers. url=${got.url}`);
    fareRows = rows;
    sourceName = 'fare_source.tsv';
  }


  // 2) aliases (optional)
  let aliasRows = [];
  try {
    const resA = await fetch("./data/place_aliases.csv", { cache: "no-cache" });
    if (resA.ok){
      const a = await resA.text();
      aliasRows = parseCSV(a).map(normalizeRowKeys);
    }
  } catch {}

  // -------------------------
  // build DB
  // -------------------------
  const fares = [];
  const placesSet = new Set();

  const seen = new Set();
  function keyOf(from,to,ptype,fromD,toD){
    return `${from}||${to}||${ptype}||${ymd(fromD)}||${ymd(toD)}`;
  }

  function shiftYear(d, plus){
    const x = new Date(d);
    x.setFullYear(x.getFullYear() + plus);
    return x;
  }

  // 「価格適用期間」の年ズレを補正：
  // 搭乗期間が年跨ぎ（例: 2025-10-26〜2026-03-28）のとき、
  // 価格適用期間が 2025-01/02/03… と入っていたら 2026 に寄せる。
  function alignToWholeRange(pFrom, pTo, wholeFrom, wholeTo){
    let from = pFrom;
    let to = pTo;
    if (!from || !to) return null;
    if (!(wholeFrom instanceof Date) || !(wholeTo instanceof Date)) return { from, to };

    // if whole crosses years
    const crosses = wholeTo.getFullYear() > wholeFrom.getFullYear();
    if (crosses){
      const startY = wholeFrom.getFullYear();
      const startM = wholeFrom.getMonth();

      // common data issue: Jan-Mar written with startY instead of endY
      if (from.getFullYear() == startY && from.getMonth() < startM) {
        from = shiftYear(from, +1);
      }
      if (to.getFullYear() == startY && to.getMonth() < startM) {
        to = shiftYear(to, +1);
      }

      // if still entirely before wholeFrom, move forward by 1 year (safety)
      if (to < wholeFrom) {
        from = shiftYear(from, +1);
        to = shiftYear(to, +1);
      }
    }

    // clamp (safety) — don't extend beyond the declared boarding window
    const vf = new Date(Math.max(from.getTime(), wholeFrom.getTime()));
    const vt = new Date(Math.min(to.getTime(), wholeTo.getTime()));
    if (vf > vt) return null;
    return { from: vf, to: vt };
  }

  for (const r of fareRows){
    const rr = normalizeRowKeys(r);

    const fromRaw = (rr.from ?? "").toString().trim();
    const toRaw   = (rr.to   ?? "").toString().trim();
    if (!fromRaw || !toRaw) continue;

    const priceType = (rr.priceType ?? "").toString().trim() || "通常";
    const fare = parseInt((rr.fare ?? "0").toString().replace(/[^0-9-]/g, ""), 10) || 0;

    // whole range (optional, but used for year-alignment)
 (optional, but used for year-alignment)
    const wholeFrom = parseDateLoose((rr.wholeFrom ?? rr.valid_from ?? "").toString().trim());
    const wholeTo   = parseDateLoose((rr.wholeTo ?? rr.valid_to ?? "").toString().trim());

    // periods (preferred)
    let periods = splitPeriods((r["価格適用期間"] ?? "").toString().trim());
    if (!periods.length){
      // fallback to whole range if no explicit periods
      if (wholeFrom && wholeTo) periods = [{ from: wholeFrom, to: wholeTo }];
    }

    for (const p of periods){
      const aligned = alignToWholeRange(p.from, p.to, wholeFrom, wholeTo);
      if (!aligned) continue;

      const key = keyOf(fromRaw, toRaw, priceType, aligned.from, aligned.to);
      if (seen.has(key)) continue;
      seen.add(key);

      fares.push({
        from: fromRaw,
        to: toRaw,
        priceType,
        fare,
        validFrom: aligned.from,
        validTo: aligned.to,
        source: sourceName
      });

      placesSet.add(fromRaw);
      placesSet.add(toRaw);
    }
  }

  // alias map (external CSV + built-in)
  const places = Array.from(placesSet).sort();
  const aliasToCanon = buildAliasDefaultsFromPlaces(places);

  // merge external aliases: csv columns = alias, canonical
  for (const a of aliasRows){
        const alias = (a.alias ?? '').toString().trim();
    const canon = (a.canonical ?? '').toString().trim();
    if (!alias || !canon) continue;
    aliasToCanon.set(normKey(alias), canon);
  }

  // build lookup map
  const map = new Map();
  for (const f of fares){
    const k = normKey(f.from) + '||' + normKey(f.to);
    if (!map.has(k)) map.set(k, []);
    map.get(k).push(f);
  }
  for (const [k, arr] of map.entries()){
    arr.sort((a,b)=> a.validFrom - b.validFrom || a.validTo - b.validTo || a.fare - b.fare);
  }

  // store
  DB.faresRows = fares;
  DB.routeMap = map;
  DB.places = places;
  DB.aliasToCanon = aliasToCanon;
  DB.meta = {
    source: sourceName,
    fares: fares.length,
    routes: map.size,
    places: places.length,
    updatedAt: new Date().toISOString().slice(0,19).replace('T',' ')
  };

  // UI meta
  const meta = DB.meta;
  $("#dbMeta").textContent = `DB: ${meta.source} / routes=${meta.routes} / fares=${meta.fares} / places=${meta.places} / updated=${meta.updatedAt}`;
  if (meta.fares === 0 || meta.places === 0){
    $("#dbMeta").textContent += "  ※DB未反映の可能性：Netlify/GitHub Pagesの公開フォルダに data/ が含まれるか、SPAリダイレクト設定で /data/* を潰していないか確認";
  }
}


function bindUI(){
  window.__legs = [];

  $("#btnParse").addEventListener("click", ()=>{
    const { legs, errors } = parseItineraryLines($("#itineraryText").value);
    if (errors.length){
      $("#parseMsg").textContent = errors.slice(0,8).join(" / ");
    } else {
      $("#parseMsg").textContent = `解析OK：${legs.length}件`;
    }
    // merge (append) not replace: business use often adds
    window.__legs = legs;
    renderLegs();
    runSearch();
  });

  $("#btnClear").addEventListener("click", ()=>{
    $("#itineraryText").value = "";
    $("#parseMsg").textContent = "";
  });

  $("#btnAddLeg").addEventListener("click", ()=>{
    const d = $("#legDate").value ? parseDateLoose($("#legDate").value) : null;
    const from = $("#fromSelect").value;
    const to = $("#toSelect").value;
    const via1 = $("#via1Select") ? $("#via1Select").value : "";
    const via2 = $("#via2Select") ? $("#via2Select").value : "";

    if (!d || !from || !to){
      $("#parseMsg").textContent = "日付・出発地・到着地を指定してください。";
      return;
    }

    const legsToAdd = [];
    if (via1 || via2){
      legsToAdd.push({ date: d, from, to, raw: `${ymd(d)} ${from}→${to}（直行候補）`, tag: "direct" });

      if (via1 && via2){
        legsToAdd.push({ date: d, from, to: via1, raw: `${ymd(d)} ${from}→${via1}（経由①）`, tag: "via" });
        legsToAdd.push({ date: d, from: via1, to: via2, raw: `${ymd(d)} ${via1}→${via2}（経由②）`, tag: "via" });
        legsToAdd.push({ date: d, from: via2, to, raw: `${ymd(d)} ${via2}→${to}（経由③）`, tag: "via" });
      } else if (via1){
        legsToAdd.push({ date: d, from, to: via1, raw: `${ymd(d)} ${from}→${via1}（経由①）`, tag: "via" });
        legsToAdd.push({ date: d, from: via1, to, raw: `${ymd(d)} ${via1}→${to}（経由②）`, tag: "via" });
      } else if (via2){
        legsToAdd.push({ date: d, from, to: via2, raw: `${ymd(d)} ${from}→${via2}（経由①）`, tag: "via" });
        legsToAdd.push({ date: d, from: via2, to, raw: `${ymd(d)} ${via2}→${to}（経由②）`, tag: "via" });
      }
    } else {
      legsToAdd.push({ date: d, from, to, raw: `${ymd(d)} ${from}→${to}`, tag: "" });
    }

    window.__legs.push(...legsToAdd);
    renderLegs();
    runSearch();
  });

  $("#btnResetLegs").addEventListener("click", ()=>{
    window.__legs = [];
    renderLegs();
    runSearch();
  });
}

(async function main(){
  try{
    await loadDB();
    renderSelectOptions();
    bindUI();
    renderLegs();
    runSearch();
  } catch (e){
    console.error(e);
    $("#parseMsg").textContent = "読み込みエラー：" + (e?.message || e);
    $("#dbMeta").textContent = "読み込み失敗";
  }
})();
</script>
</body>
</html>
